using UnityEngine;
using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

namespace SplineMesh {
    /// <summary>
    /// A component that creates a deformed mesh from a given one along the given spline segment.
    /// The source mesh will always be bended along the X axis.
    /// It can work on a cubic bezier curve or on any interval of a given spline.
    /// On the given interval, the mesh can be place with original scale, stretched, or repeated.
    /// The resulting mesh is stored in a MeshFilter component and automaticaly updated on the next update if the spline segment change.
    /// </summary>
    [DisallowMultipleComponent]
    [RequireComponent(typeof(MeshFilter))]
    public class MeshBender : MonoBehaviour {
        private bool _useTangents;
        private bool isDirty;
        private Mesh result;
        private Spline spline;
        private float intervalStart, intervalEnd;
        private CurveSamplesLerpPair[] _curveSamplesLerpPairs;
        
        private MeshVertex[] _sourceVertices;
        private int[] _triangles;
        private Vector3[] _vertices;
        private Vector3[] _normals;
        private Vector2[] _uv;
        private Vector2[] _uv2;
        private Vector2[] _uv3;
        private Vector2[] _uv4;
        private Vector2[] _uv5;
        private Vector2[] _uv6;
        private Vector2[] _uv7;
        private Vector2[] _uv8;

        private SourceMesh _source;

        private int _repetitionCount;
        
        public void SetSource(SourceMesh source) {
            if (source == _source) return;
            _sourceVertices = source.Vertices;
            _source = source;
            _triangles = _source.Triangles;
            _uv = _source.UV;
            _uv2 = _source.UV2;
            _uv3 = _source.UV3;
            _uv4 = _source.UV4;
            _uv5 = _source.UV5;
            _uv6 = _source.UV6;
            _uv7 = _source.UV7;
            _uv8 = _source.UV8;
            _vertices = new Vector3[_sourceVertices.Length];
            _normals = new Vector3[_sourceVertices.Length];
            _curveSamplesLerpPairs = new CurveSamplesLerpPair[_source.SampleGroups.Length];
        }
        
        public void SetInterval(Spline spline, float intervalStart, float intervalEnd = 0) {
            if (this.spline == spline && Math.Abs(this.intervalStart - intervalStart) < float.Epsilon &&
                Math.Abs(this.intervalEnd - intervalEnd) < float.Epsilon) return;
            if (spline == null) throw new ArgumentNullException("spline");
            if (intervalStart < 0 || intervalStart >= spline.Length) {
                throw new ArgumentOutOfRangeException("interval start must be 0 or greater and lesser than spline length (was " + intervalStart + ")");
            }
            if (intervalEnd != 0 && intervalEnd <= intervalStart || intervalEnd > spline.Length) {
                throw new ArgumentOutOfRangeException("interval end must be 0 or greater than interval start, and lesser than spline length (was " + intervalEnd + ")");
            }

            if (spline != this.spline) {
                if (this.spline != null) {
                    this.spline.Changed -= SetDirty;
                }
                this.spline = spline;
                spline.Changed += SetDirty;   
            }
            
            this.intervalStart = intervalStart;
            this.intervalEnd = intervalEnd;
            SetDirty();
        }

        private void OnEnable() {
            if(GetComponent<MeshFilter>().sharedMesh != null) {
                result = GetComponent<MeshFilter>().sharedMesh;
            } else {
                GetComponent<MeshFilter>().sharedMesh = result = new Mesh();
                result.name = "Generated by " + GetType().Name;
            }
        }

        private void LateUpdate() {
            ComputeIfNeeded();
        }

        public void ComputeIfNeeded() {
            if (isDirty) {
                Compute();
            }
        }

        private void SetDirty() {
            isDirty = true;
        }

        /// <summary>
        /// Bend the mesh. This method may take time and should not be called more than necessary.
        /// Consider using <see cref="ComputeIfNeeded"/> for faster result.
        /// </summary>
        private  void Compute() {
            isDirty = false;
            FillStretch();
        }

        private void OnDestroy() {
            
        }

        private void FillStretch() {
            var jobVerticesIn = new NativeArray<MeshVertex>(_sourceVertices.Length, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            var jobVerticesOut = new NativeArray<float3>(_sourceVertices.Length, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            var jobNormalsOut = new NativeArray<float3>(_sourceVertices.Length, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            var jobCurveSamples = new NativeArray<CurveSample>(_sourceVertices.Length, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            
            var jobCurveSamplesLerpPairs = new NativeArray<CurveSamplesLerpPair>(_source.SampleGroups.Length, Allocator.TempJob,
                NativeArrayOptions.UninitializedMemory);
            var sampleGroupsNativeArray = new NativeArray<CurveSample>(_source.SampleGroups.Length,
                Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            var verticesToSampleGroupsNativeArray = new NativeArray<int>(_sourceVertices.Length,
                Allocator.TempJob, NativeArrayOptions.UninitializedMemory);

            for (var i = 0; i < _source.SampleGroups.Length; i++) {
                var distanceRate = _source.SampleGroups[i];
                var intervalLength =
                    intervalEnd == 0 ? spline.Length - intervalStart : intervalEnd - intervalStart;
                var distOnSpline = intervalStart + intervalLength * distanceRate;
                if (distOnSpline > spline.Length) {
                    distOnSpline = spline.Length;
                }

                _curveSamplesLerpPairs[i] = spline.GetSampleAtDistance(distOnSpline);
            }

            jobCurveSamplesLerpPairs.CopyFrom(_curveSamplesLerpPairs);
            verticesToSampleGroupsNativeArray.CopyFrom(_source.VerticesToSampleGroups);

            var jobCurveSamplesLerp = new CurveSamplesLerpJob {
                CurveSamplesPairs = jobCurveSamplesLerpPairs,
                Results = sampleGroupsNativeArray
            };
            var jobHandle = jobCurveSamplesLerp.Schedule(_curveSamplesLerpPairs.Length, 8, default);

            var curveSamplesGroupsJob = new CurveSamplesGroupsJob {
                CurveSampleGroups = sampleGroupsNativeArray,
                VerticesToSampleGroups = verticesToSampleGroupsNativeArray,
                Result = jobCurveSamples
            };

            jobHandle = curveSamplesGroupsJob.Schedule(_sourceVertices.Length, 8, jobHandle);

            jobVerticesIn.CopyFrom(_sourceVertices);

            var job = new CurveSampleBentJob {
                Curves = jobCurveSamples,
                VerticesIn = jobVerticesIn,
                VerticesOut = jobVerticesOut,
                NormalsOut = jobNormalsOut
            };
            job.Schedule(_sourceVertices.Length, 8, jobHandle).Complete();
            
            jobVerticesOut.Reinterpret<Vector3>().CopyTo(_vertices);
            jobNormalsOut.Reinterpret<Vector3>().CopyTo(_normals);

            jobCurveSamples.Dispose();
            jobVerticesIn.Dispose();
            jobVerticesOut.Dispose();
            jobNormalsOut.Dispose();
            jobCurveSamplesLerpPairs.Dispose();
            sampleGroupsNativeArray.Dispose();
            verticesToSampleGroupsNativeArray.Dispose();

            MeshUtility.Update(result,
                _triangles,
                _vertices,
                _normals,
                _useTangents,
                _uv, _uv2, _uv3, _uv4, _uv5, _uv6, _uv7, _uv8);
            
            if (TryGetComponent(out MeshCollider collider)) {
                collider.sharedMesh = result;
            }
        }


    }
}